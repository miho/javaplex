package edu.stanford.math.plex4.homology.streams.interfaces;


/**
 * This interface defines the functionality of a streamed filtered
 * chain complex. An implementing class must provide functionality
 * for iterating through the chain complex, as well as providing
 * information about the basis elements (such as their filtration
 * values and dimension).
 * 
 * Note that there are two types of grading on our notion of a 
 * filtered chain complex. The first is that of the filtration index.
 * In other words we have the decomposition
 * ... -> C_{i-1} -> C_{i} -> C_{i+1} -> ...
 * with elements in C_i having the filtration value given by a_i. For
 * this notion of filtration, we may assume without loss of generality
 * that each C_i contains at most one basis element. However, we also
 * have the more standard homological grading given by the "dimension"
 * of a basis element. Since we are not restricting ourselves to basis
 * elements consisting of simplices, the dimension may or may not carry
 * geometric meaning. Nevertheless it plays an important role.
 * 
 * An implementing class must iterate through the basis elements in 
 * non-decreasing order of filtration value. This defines a partial
 * order on the set of basis elements within the entire chain complex.
 * The completion of this partial order to a total order can depend
 * on the implementer, but must be such that the boundary of a basis 
 * element must always precede the element itself. In practice, the 
 * completion of the partial order will be based on dimension.
 * 
 * The underlying type of the stream, T, will vary depending on the
 * context. Below are some examples:
 * T = Simplex: a standard filtered simplicial complex
 * T = Cell: a standard filtered CW complex
 * T = GenericPair<T, U>: A pair may represent a tensor product
 * 
 * This interface is the highest level in the filtered stream classes
 * and interfaces, and defines the basic functionality that all such
 * streams must implement.
 * 
 * It is important to note that functions such as getBoundary, 
 * getFiltrationValue and getDimension do not only depend on the 
 * queried basis element (ie. the simplex in question), but also 
 * the properties of the chain complex. For example, the getBoundary
 * function may return the coboundary of a simplex rather than a 
 * boundary in the case that we are working in the context of a cochain
 * complex. Or, the getDimension may return a shifted version of
 * the actual geometric dimension of a simplex.
 * 
 * A note on language: We call the underlying parameterized type T as the
 * basis type. This is justified by the fact that the modules in the chain
 * complex are free modules, and are generated by objects with type T.
 * 
 * @author Andrew Tausz
 *
 * @param <T> the underlying type of the generators in the free modules of the complex
 */
public interface AbstractFilteredStream<T> extends Iterable<T> {
	/**
	 * This function returns the filtration value of a simplex
	 * within a filtered simplicial complex. The filtration value
	 * is the threshold parameter at which the simplex appears within
	 * the filtration.
	 * 
	 * @param basisElement the simplex to query
	 * @return the filtration value of the provided simplex
	 */
	public double getFiltrationValue(T basisElement);
	
	public int getFiltrationIndex(T basisElement);
	
	/**
	 * This function returns the elements in the boundary of the supplied
	 * basisElement, without the coefficients. We do not integrate the
	 * elements of the boundary array with their respective coefficients
	 * since this interface is designed to be independent of the algebraic
	 * environment.
	 * 
	 * @param basisElement the element to get the boundary of
	 * @return an array containing the boundary elements of the queried element
	 */
	public T[] getBoundary(T basisElement);
	
	/**
	 * This function returns the coefficients of the boundary of the supplied
	 * basis element. Note that in many cases, this will be the standard array
	 * consisting of alternating signs: [1, -1, 1, -1, ...]. However, this
	 * will not always be the case. Thus this must be left abstract. Also note
	 * that the coefficients will always be integers.
	 * 
	 * @param basisElement the element to get the boundary coefficients of
	 * @return an array containing the boundary coefficients of the queried element
	 */
	public int[] getBoundaryCoefficients(T basisElement);
	
	/**
	 * This function returns the dimension of a basis element within
	 * the chain complex.
	 * 
	 * @param basisElement the element to get the dimension of
	 * @return the dimension of the basis element within the chain complex
	 */
	public int getDimension(T basisElement);
	
	/**
	 * This function prepares the stream for use by a consumer, such as the
	 * PersistentHomology class. After finalization, the stream cannot not be 
	 * modified by adding or removing elements. In practice, the finalize
	 * procedure will probably do some sorting and construction of data
	 * structures necessary for iterating through the stream.  
	 */
	public void finalizeStream();
	
	/**
	 * This function checks whether the finalize() function has been called.
	 * 
	 * @return true if the stream has been finalized, and false otherwise
	 */
	public boolean isFinalized();
}
